//
//  Generated by pegged 0.5.0.
//  Fork: https://github.com/hydrixos/pegged
//

#import "PEGParser.h"
#import "Compiler.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

NSString *PEGParserErrorStringLocationKey		= @"PEGParserErrorStringLocation";
NSString *PEGParserErrorStringLengthKey		= @"PEGParserErrorStringLength";
NSString *PEGParserErrorStringKey				= @"PEGParserErrorString";

#pragma mark - Internal types

// A block implementing a certain parsing rule
typedef BOOL (^PEGParserRule)(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures);

// A block implementing a certain parser action
typedef id (^PEGParserAction)(PEGParser *self, NSString *text);


/*!
 @abstract Internally used class for storing captured text results for actions.
 */
@interface PEGParserCapture : NSObject

// The position index used for text capturing
@property NSUInteger begin;
@property NSUInteger end;

// The parsed ranged used for this capture
@property NSRange parsedRange;

// The action associated with a capture
@property (copy) PEGParserAction action;

// The count of captured results available to an action
@property NSInteger capturedResultsCount;

// All results captured by the action
@property NSArray *allResults;

// The index of the next result to be read by the action
@property NSInteger nextResultIndex;

@end

@implementation PEGParserCapture
@end


/*!
 @abstract Internal parser methods
 */
@interface PEGParser ()
{
	// The last error state
	NSError *_lastError;
	
	// The rule set used by the parser
	NSMutableDictionary *_rules;
	
	// The current string position
	const char *_cstring;
	NSUInteger _index;
	NSUInteger _limit;
		
	// Specifies whether the parser is currently capturing
	BOOL _capturing;
	
	// All currently matched captures
	NSMutableArray *_captures;
	
	// The results of the last actions
	NSMutableArray *_actionResults;

	// The capture of the currently performed action
	PEGParserCapture *_currentCapture;
}

// Public parser state information
@property (readonly) NSUInteger captureStart;
@property (readonly) NSUInteger captureEnd;
@property (readonly) NSString* string;

@property (readonly) NSUInteger index;

@end


@implementation PEGParser

- (id)init
{
    self = [super init];
    
    if (self)
    {
        _rules = [NSMutableDictionary new];
        _captures = [NSMutableArray new];
		_actionResults = [NSMutableArray new];

		[self addRule:__AND withName:@"AND"];
		[self addRule:__AT withName:@"AT"];
		[self addRule:__Action withName:@"Action"];
		[self addRule:__BEGIN withName:@"BEGIN"];
		[self addRule:__CIRCUMFLEX withName:@"CIRCUMFLEX"];
		[self addRule:__CLOSE withName:@"CLOSE"];
		[self addRule:__Char withName:@"Char"];
		[self addRule:__Class withName:@"Class"];
		[self addRule:__Code withName:@"Code"];
		[self addRule:__Comment withName:@"Comment"];
		[self addRule:__DOT withName:@"DOT"];
		[self addRule:__Declaration withName:@"Declaration"];
		[self addRule:__Definition withName:@"Definition"];
		[self addRule:__END withName:@"END"];
		[self addRule:__Effect withName:@"Effect"];
		[self addRule:__EndOfDecl withName:@"EndOfDecl"];
		[self addRule:__EndOfFile withName:@"EndOfFile"];
		[self addRule:__EndOfLine withName:@"EndOfLine"];
		[self addRule:__Expression withName:@"Expression"];
		[self addRule:__ExtraCode withName:@"ExtraCode"];
		[self addRule:__Fail withName:@"Fail"];
		[self addRule:__GlobalImportIdentifier withName:@"GlobalImportIdentifier"];
		[self addRule:__Grammar withName:@"Grammar"];
		[self addRule:__HorizSpace withName:@"HorizSpace"];
		[self addRule:__IMPORT withName:@"IMPORT"];
		[self addRule:__IdentCont withName:@"IdentCont"];
		[self addRule:__IdentStart withName:@"IdentStart"];
		[self addRule:__Identifier withName:@"Identifier"];
		[self addRule:__ImportIdentifier withName:@"ImportIdentifier"];
		[self addRule:__LEFTARROW withName:@"LEFTARROW"];
		[self addRule:__Literal withName:@"Literal"];
		[self addRule:__LocalImportIdentifier withName:@"LocalImportIdentifier"];
		[self addRule:__NOT withName:@"NOT"];
		[self addRule:__OPEN withName:@"OPEN"];
		[self addRule:__OPTION withName:@"OPTION"];
		[self addRule:__PERCENT withName:@"PERCENT"];
		[self addRule:__PLUS withName:@"PLUS"];
		[self addRule:__PROPERTY withName:@"PROPERTY"];
		[self addRule:__Prefix withName:@"Prefix"];
		[self addRule:__Primary withName:@"Primary"];
		[self addRule:__PropIdentifier withName:@"PropIdentifier"];
		[self addRule:__PropParamaters withName:@"PropParamaters"];
		[self addRule:__QUESTION withName:@"QUESTION"];
		[self addRule:__Range withName:@"Range"];
		[self addRule:__SLASH withName:@"SLASH"];
		[self addRule:__STAR withName:@"STAR"];
		[self addRule:__Sequence withName:@"Sequence"];
		[self addRule:__Space withName:@"Space"];
		[self addRule:__Spacing withName:@"Spacing"];
		[self addRule:__Suffix withName:@"Suffix"];
    }
    
    return self;
}


#pragma mark - String matching

- (void)beginCapture
{
    if (_capturing) _captureStart = _index;
}

- (void)endCapture
{
    if (_capturing) _captureEnd = _index;
}

- (BOOL)invertWithCaptures:(NSInteger *)localCaptures startIndex:(NSInteger)startIndex block:(PEGParserRule)rule
{
	NSInteger temporaryCaptures = *localCaptures;
	
	// We are in an error state. Just stop.
	if (_lastError)
		return NO;
	
    BOOL matched = ![self matchOneWithCaptures:&temporaryCaptures startIndex:startIndex block:rule];
	if (matched)
		*localCaptures = temporaryCaptures;
	
	return matched;
}

- (BOOL)lookAheadWithCaptures:(NSInteger *)localCaptures startIndex:(NSInteger)startIndex block:(PEGParserRule)rule
{
    NSUInteger index=_index;

	// We are in an error state. Just stop.
	if (_lastError)
		return NO;
	
    BOOL capturing = _capturing;
    _capturing = NO;
	
	NSInteger temporaryCaptures = *localCaptures;
	
    BOOL matched = rule(self, startIndex, &temporaryCaptures);
    _capturing = capturing;
    _index=index;
	_lastError = nil;
	
    return matched;
}

- (BOOL)matchDot
{
    if (_index >= _limit)
		return NO;
	
    ++_index;
    return YES;
}

- (BOOL)matchOneWithCaptures:(NSInteger *)localCaptures startIndex:(NSInteger)startIndex block:(PEGParserRule)rule
{
	// We are in an error state. Just stop.
	if (_lastError)
		return NO;
	
    NSUInteger index=_index, captureCount=[_captures count];
	NSInteger temporaryCaptures = *localCaptures;
	
	// Try to match
    if (rule(self, startIndex, &temporaryCaptures)) {
		*localCaptures = temporaryCaptures;
        return YES;
	}
	
	// Restore old state
    _index=index;
	
    if ([_captures count] > captureCount) {
        NSRange rangeToRemove = NSMakeRange(captureCount, [_captures count]-captureCount);
        [_captures removeObjectsInRange:rangeToRemove];
    }
	
    return NO;
}

- (BOOL)matchManyWithCaptures:(NSInteger *)localCaptures startIndex:(NSInteger)startIndex block:(PEGParserRule)rule
{
	// We are in an error state. Just stop.
	if (_lastError)
		return NO;
	
	// We need at least one match
    if (![self matchOneWithCaptures:localCaptures startIndex:startIndex block:rule])
        return NO;
	
	// Match others
    while ([self matchOneWithCaptures:localCaptures startIndex:startIndex block:rule])
		;
    
	return YES;
}

- (BOOL)matchRule:(NSString *)ruleName startIndex:(NSInteger)startIndex asserted:(BOOL)asserted
{
    NSArray *rules = [_rules objectForKey: ruleName];

	// We are in an error state. Just stop.
	if (_lastError)
		return NO;
    
	if (![rules count])
        NSLog(@"Couldn't find rule name \"%@\".", ruleName);
	
	for (PEGParserRule rule in rules) {
		NSInteger localCaptures = 0;
		
		if ([self matchOneWithCaptures:&localCaptures startIndex:_index block:rule])
			return YES;
	}

	if (asserted)
		[self setErrorWithMessage: [NSString stringWithFormat: @"Unmatched%@", ruleName] location:startIndex length:(_index - startIndex)];
	
    return NO;
}

- (BOOL)matchString:(char *)literal startIndex:(NSInteger)startIndex asserted:(BOOL)asserted
{
	NSInteger saved = _index;

	while (*literal) {
		if ((_index >= _limit) || (_cstring[_index] != *literal)) {
			_index = saved;
			
			if (asserted)
				[self setErrorWithMessage: [NSString stringWithFormat: @"Missing:%s", literal] location:saved length:(_index - saved + 1)];
			
			return NO;
		}
		++literal;
		++_index;
	}

    return YES;
}

- (BOOL)matchClass:(unsigned char *)bits
{
    if (_index >= _limit) return NO;
	
    int c = [_string characterAtIndex:_index];
    
	if (bits[c >> 3] & (1 << (c & 7))) {
        ++_index;
        return YES;
    }
	
    return NO;
}

- (void)setErrorWithMessage:(NSString *)message location:(NSInteger)location length:(NSInteger)length
{
	if (!_lastError)
		_lastError = [NSError errorWithDomain:NSCocoaErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey: message, PEGParserErrorStringLocationKey: @(location), PEGParserErrorStringLengthKey: @(length), PEGParserErrorStringKey: [_string copy]}];
}

- (void)clearError
{
	_lastError = nil;
}


#pragma mark - Action handling

- (void)performActionUsingCaptures:(NSInteger)captures startIndex:(NSInteger)startIndex block:(PEGParserAction)action
{
    PEGParserCapture *capture = [PEGParserCapture new];
    
	capture.begin = _captureStart;
    capture.end = _captureEnd;
    
	capture.action = action;
	capture.parsedRange = NSMakeRange(startIndex, _index - startIndex);
	
	capture.capturedResultsCount = captures;

    [_captures addObject:capture];
}

- (void)pushResult:(id)result
{
	[_actionResults addObject: result];
}

- (id)nextResult
{
	return [_currentCapture.allResults objectAtIndex: _currentCapture.nextResultIndex++];
}

- (id)nextResultOrNil
{
	if (_currentCapture.allResults.count >= _currentCapture.nextResultIndex)
		return nil;
	
	return [self nextResult];
}

- (id)resultAtIndex:(NSInteger)index
{
	return [_currentCapture.allResults objectAtIndex: index];
}

- (NSInteger)resultCount
{
	return _currentCapture.capturedResultsCount;
}

- (NSArray *)allResults
{
	return _currentCapture.allResults;
}

- (NSRange)rangeForCurrentAction
{
	return _currentCapture.parsedRange;
}


#pragma mark - Rule definitions

- (void)addRule:(PEGParserRule)rule withName:(NSString *)name
{
    NSMutableArray *rules = [_rules objectForKey:name];
    if (!rules) {
        rules = [NSMutableArray new];
        [_rules setObject:rules forKey:name];
    }
    
    [rules addObject:rule];
}

static PEGParserRule __AND = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"&" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __AT = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"@" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Action = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"{" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser beginCapture];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchClass: (unsigned char *)"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\337\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"])
			return NO;
		return YES;
	}];
	
	[parser endCapture];
	
	if (![parser matchString:"}" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __BEGIN = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"<" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __CIRCUMFLEX = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"^" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __CLOSE = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:")" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Char = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\\" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\204\000\000\000\000\000\000\070\000\100\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\\" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\\" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			[parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
					return NO;
				return YES;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\\x" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\003\176\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\003\176\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if ([parser matchString:"\\" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}])
				return NO;
			
			if (![parser matchDot])
				return NO;
		
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Class = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"[" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser beginCapture];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchString:"]" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return NO;
		
		if (![parser matchRule: @"Range" startIndex:startIndex asserted:NO])
			return NO;
	
		return YES;
	}];
	
	[parser endCapture];
	
	if (![parser matchString:"]" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Code = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"{{" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser beginCapture];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchClass: (unsigned char *)"\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\337\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"])
			return NO;
		return YES;
	}];
	
	[parser endCapture];
	
	if (![parser matchString:"}}" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Comment = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"#" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchRule: @"EndOfLine" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return NO;
		
		if (![parser matchDot])
			return NO;
	
		return YES;
	}];
	
	if (![parser matchRule: @"EndOfLine" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __DOT = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"." startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Declaration = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"OPTION" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchString:"case-insensitive" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}];
			
			if (![parser matchRule: @"EndOfDecl" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 self.compiler.caseInsensitive = YES;
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"IMPORT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"ImportIdentifier" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}];
			
			if (![parser matchRule: @"EndOfDecl" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedImport:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"PROPERTY" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"PropParamaters" startIndex:startIndex asserted:NO])
					return NO;
				
				[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
					 [self.compiler parsedPropertyParameters:text];
				
					return nil;
				}];
			
				return YES;
			}];
			
			if (![parser matchRule: @"PropIdentifier" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedPropertyType:text];
			
				return nil;
			}];
			
			[parser beginCapture];
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchString:"*" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}];
			
			[parser endCapture];
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}];
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedPropertyStars:text];
			
				return nil;
			}];
			
			if (![parser matchRule: @"PropIdentifier" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"EndOfDecl" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedPropertyName:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"ExtraCode" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Definition = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchRule: @"Identifier" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
		 [self.compiler startRule:text];
	
		return nil;
	}];
	
	if (![parser matchRule: @"LEFTARROW" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Expression" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
		 [self.compiler parsedRule];
	
		return nil;
	}];
	
	return YES;
};

static PEGParserRule __END = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:">" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Effect = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Code" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedCode:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Action" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedAction:text returnValue:NO];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"CIRCUMFLEX" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Action" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedAction:text returnValue:YES];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Fail" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedFail: text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"BEGIN" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler beginCapture];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"END" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler endCapture];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __EndOfDecl = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:";" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"EndOfLine" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Comment" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __EndOfFile = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchDot])
			return NO;
	
		return YES;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __EndOfLine = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\r\n" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\n" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\r" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Expression = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchRule: @"Sequence" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"SLASH" startIndex:startIndex asserted:NO])
			return NO;
		
		if (![parser matchRule: @"Sequence" startIndex:startIndex asserted:NO])
			return NO;
		
		[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
			 [self.compiler parsedAlternate];
		
			return nil;
		}];
	
		return YES;
	}];
	
	return YES;
};

static PEGParserRule __ExtraCode = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"%%" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser beginCapture];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchClass: (unsigned char *)"\377\377\377\377\337\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"])
			return NO;
		return YES;
	}];
	
	[parser endCapture];
	
	if (![parser matchString:"%%" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
		 [self.compiler parsedExtraCode: text];
	
		return nil;
	}];
	
	return YES;
};

static PEGParserRule __Fail = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"@!" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser beginCapture];
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\007\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
			return NO;
		return YES;
	}])
		return NO;
	
	[parser endCapture];
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __GlobalImportIdentifier = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser beginCapture];
	
	if (![parser matchString:"<" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchString:"<" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return NO;
		
		if (![parser matchDot])
			return NO;
	
		return YES;
	}])
		return NO;
	
	if (![parser matchString:">" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser endCapture];
	
	return YES;
};

static PEGParserRule __Grammar = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"Declaration" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"Definition" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}])
		return NO;
	
	if (![parser matchRule: @"EndOfFile" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __HorizSpace = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:" " startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\t" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __IMPORT = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"@import" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	return YES;
};

static PEGParserRule __IdentCont = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"IdentStart" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __IdentStart = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchClass: (unsigned char *)"\000\000\000\000\000\000\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
		return NO;
	
	return YES;
};

static PEGParserRule __Identifier = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser beginCapture];
	
	if (![parser matchRule: @"IdentStart" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"IdentCont" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	[parser endCapture];
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __ImportIdentifier = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"LocalImportIdentifier" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"GlobalImportIdentifier" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __LEFTARROW = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"<-" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Literal = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			[parser beginCapture];
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
					if ([parser matchClass: (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
						return NO;
				
					return YES;
				}])
					return NO;
				
				if (![parser matchRule: @"Char" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}];
			
			[parser endCapture];
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			[parser beginCapture];
			
			[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
					if ([parser matchClass: (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
						return NO;
				
					return YES;
				}])
					return NO;
				
				if (![parser matchRule: @"Char" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}];
			
			[parser endCapture];
			
			if (![parser matchClass: (unsigned char *)"\000\000\000\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"])
				return NO;
			
			if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __LocalImportIdentifier = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser beginCapture];
	
	if (![parser matchString:"\"" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchString:"\"" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return NO;
		
		if (![parser matchDot])
			return NO;
	
		return YES;
	}])
		return NO;
	
	if (![parser matchString:"\"" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser endCapture];
	
	return YES;
};

static PEGParserRule __NOT = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"!" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __OPEN = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"(" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __OPTION = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"@option" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __PERCENT = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"%" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __PLUS = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"+" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __PROPERTY = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"@property" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Prefix = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"AND" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Suffix" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedLookAhead];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"NOT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Suffix" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedNegativeLookAhead];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"AND" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Action" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedLookAhead:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"NOT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Action" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedNegativeLookAhead:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Suffix" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Effect" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Primary = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Identifier" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if ([parser matchRule: @"LEFTARROW" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedIdentifier:text capturing:NO asserted:NO];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"PERCENT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Identifier" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if ([parser matchRule: @"LEFTARROW" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedIdentifier:text capturing:YES asserted:NO];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"AT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Identifier" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if ([parser matchRule: @"LEFTARROW" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedIdentifier:text capturing:NO asserted:YES];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"AT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"PERCENT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Identifier" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser lookAheadWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if ([parser matchRule: @"LEFTARROW" startIndex:startIndex asserted:NO])
					return NO;
			
				return YES;
			}])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedIdentifier:text capturing:YES asserted:YES];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"OPEN" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Expression" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"CLOSE" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Literal" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedLiteral:text asserted:NO];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"AT" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Literal" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedLiteral:text asserted:YES];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Class" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedClass:text];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"DOT" startIndex:startIndex asserted:NO])
				return NO;
			
			[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
				 [self.compiler parsedDot];
			
				return nil;
			}];
		
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __PropIdentifier = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser beginCapture];
	
	if (![parser matchRule: @"IdentStart" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"IdentCont" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	[parser endCapture];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	return YES;
};

static PEGParserRule __PropParamaters = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser beginCapture];
	
	if (![parser matchString:"(" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchClass: (unsigned char *)"\377\377\377\377\377\375\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"])
			return NO;
		return YES;
	}])
		return NO;
	
	if (![parser matchString:")" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser endCapture];
	
	if (![parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"HorizSpace" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __QUESTION = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"?" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Range = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Char" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchString:"-" startIndex:startIndex asserted:NO])
				return NO;
			
			if (![parser matchRule: @"Char" startIndex:startIndex asserted:NO])
				return NO;
		
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"Char" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __SLASH = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"/" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __STAR = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchString:"*" startIndex:startIndex asserted:NO])
		return NO;
	
	if (![parser matchRule: @"Spacing" startIndex:startIndex asserted:NO])
		return NO;
	
	return YES;
};

static PEGParserRule __Sequence = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"Prefix" startIndex:startIndex asserted:NO])
			return NO;
		return YES;
	}];
	
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchRule: @"Prefix" startIndex:startIndex asserted:NO])
			return NO;
		
		[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
			 [self.compiler append];
		
			return nil;
		}];
	
		return YES;
	}];
	
	return YES;
};

static PEGParserRule __Space = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:" " startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchString:"\t" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if (![parser matchRule: @"EndOfLine" startIndex:startIndex asserted:NO])
				return NO;
			return YES;
		}])
			return YES;
	
		return NO;
	}])
		return NO;
	
	return YES;
};

static PEGParserRule __Spacing = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	[parser matchManyWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"Space" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}])
				return YES;
		
			if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"Comment" startIndex:startIndex asserted:NO])
					return NO;
				return YES;
			}])
				return YES;
		
			return NO;
		}])
			return NO;
	
		return YES;
	}];
	
	return YES;
};

static PEGParserRule __Suffix = ^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
	if (![parser matchRule: @"Primary" startIndex:startIndex asserted:NO])
		return NO;
	
	[parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
		if (![parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
			if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"QUESTION" startIndex:startIndex asserted:NO])
					return NO;
				
				[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
					 [self.compiler parsedQuestion];
				
					return nil;
				}];
			
				return YES;
			}])
				return YES;
		
			if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"STAR" startIndex:startIndex asserted:NO])
					return NO;
				
				[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
					 [self.compiler parsedStar];
				
					return nil;
				}];
			
				return YES;
			}])
				return YES;
		
			if ([parser matchOneWithCaptures:localCaptures startIndex:startIndex block:^(PEGParser *parser, NSInteger startIndex, NSInteger *localCaptures) {
				if (![parser matchRule: @"PLUS" startIndex:startIndex asserted:NO])
					return NO;
				
				[parser performActionUsingCaptures:*localCaptures startIndex:startIndex block:^id(PEGParser *self, NSString *text) {
					 [self.compiler parsedPlus];
				
					return nil;
				}];
			
				return YES;
			}])
				return YES;
		
			return NO;
		}])
			return NO;
	
		return YES;
	}];
	
	return YES;
};


#pragma mark - Parsing methods

- (NSString *)yyText:(NSUInteger)begin to:(NSUInteger)end
{
    NSInteger len = end - begin;
    if (len <= 0)
        return @"";
    return [_string substringWithRange:NSMakeRange(begin, len)];
}

- (BOOL)parseString:(NSString *)string usingResult:(id *)result
{
	// Prepare parser input
	_string = string;
	#ifndef __PEG_PARSER_CASE_INSENSITIVE__
		_cstring = [_string UTF8String];
	#else
		_cstring = [[_string lowercaseString] UTF8String];
	#endif
		
    // Setup capturing limits
	_limit  = [_string lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    _index  = 0;

	_captureStart= _captureEnd= _index;
    _capturing = YES;
    
	// Do string matching
    BOOL matched = [self matchRule: @"Grammar" startIndex:_index asserted:YES];
    
	// Process actions
    if (matched) {
		for (PEGParserCapture *capture in _captures) {
			_currentCapture = capture;

			// Prepare results
			NSInteger resultsCount = _currentCapture.capturedResultsCount;
			NSRange resultsRange = NSMakeRange(_actionResults.count - resultsCount, resultsCount);
			
			if (resultsCount) {
				// Read all results
				capture.allResults = [_actionResults subarrayWithRange: resultsRange];
				capture.nextResultIndex = 0;
				
				// Remove results from stack
				[_actionResults removeObjectsInRange: resultsRange];
			}
			
			id result = capture.action(self, [self yyText:capture.begin to:capture.end]);
			if (result) {
				// Set parsing range for diagnostics
				if ([result respondsToSelector: @selector(setParsingRange:)])
					[result setParsingRange: capture.parsedRange];
				
				[self pushResult: result];
			}
		}
		
		// Provide final result if any
		if (_actionResults.count)
			if (result) *result = _actionResults.lastObject;
	}
	
    // Cleanup parser
    _string = nil;
    _cstring = nil;
	_actionResults = nil;
		
	return matched;
}

- (BOOL)parseString:(NSString *)string
{
	return [self parseString:string usingResult:NULL];
}


#pragma mark - Helper methods

- (NSInteger)lineNumberForIndex:(NSInteger)index
{
	__block NSInteger line = 0;
	
	[_string enumerateSubstringsInRange:NSMakeRange(0, index >= _string.length ? _string.length-1 : index) options:NSStringEnumerationByLines|NSStringEnumerationSubstringNotRequired usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {
		line ++;
	}];
	
	return line;
}

- (NSInteger)columnNumberForIndex:(NSInteger)index
{
	return index - [_string lineRangeForRange: NSMakeRange(index >= _string.length ? _string.length-1 : index, 1)].location;
}

- (NSString *)positionDescriptionForIndex:(NSInteger)index
{
	return [NSString stringWithFormat: @"line: %li, column: %li", [self lineNumberForIndex: index], [self columnNumberForIndex: index]];
}

@end
